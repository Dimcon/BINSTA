

ripples = {}
rippleCounter = 0

function DrawRipples() {
    //for (index in ripples) {
    //    let ripple = ripples[index]
    //    ripple.animFloat += (16 / ripple.duration)
    //    let animPos = sin(radians(((1 - ripple.animFloat)*90)))
    //    let transparency =
    //        ripple.minTransparency +
    //            (
    //            (ripple.maxTransparency - ripple.minTransparency)
    //            * (1 - abs((animPos - 0.5)*2))
    //            )
    //    noFill()
    //    strokeWeight((ripple.maxthickness * unitsize) * animPos)
    //    ripple.color.levels[3] = (transparency)
    //    stroke(ripple.color.levels[0],ripple.color.levels[1],ripple.color.levels[2],transparency)
    //    let newvecposition = ripple.position
    //    let radius = (ripple.maxRadius * unitsize) * ripple.animFloat
    //    if (ripple.CoordsRelative) {
    //        newvecposition = ScreenCoordToPlaneCoord(ripple.position)
    //    }
    //    ellipse(newvecposition.x,newvecposition.y,radius,radius)
    //    invalidate()
    //    if (ripple.animFloat >= 1) {
    //        MinusLoop()
    //        delete ripples[index]
    //    }
    //}
}

function AddRipple(rippledata) {
   //AddLoop()
   //let mvecx = (Uservector.x + mouseX) / unitsize
   //let mvecy = (Uservector.y + mouseY) / unitsize
   //defaults = {
   //    "color":color(80,255,80),
   //    "duration":1500,
   //    "animFloat":0,
   //    "maxthickness":1,
   //    "rings":3,
   //    "ringspace": 0.4,
   //    "maxRadius":10,
   //    "minTransparency":0,
   //    "maxTransparency":255,
   //    "rippleIndex":-1,
   //    "position": createVector(mvecx,mvecy),
   //    "CoordsRelative":true
   //}
   //for (dataname in defaults) {
   //       if (!(dataname in rippledata)) {
   //            rippledata[dataname] = defaults[dataname]
   //       }
   //}
   //rippledata["rippleIndex"] = rippleCounter
   //ripples[rippleCounter] = rippledata
   //rippleCounter += 1
   //return rippleCounter - 1
}


//# sourceURL=RippleTech.js